
#********************************************************************
#      File:    ocsf.py
#      Author:  Sam Strachan
#
#      Description:
#       ocsf adapter
#
#      Copyright (c) 2017 by Cisco Systems, Inc.
#
#       ALL RIGHTS RESERVED. THESE SOURCE FILES ARE THE SOLE PROPERTY
#       OF CISCO SYSTEMS, Inc. AND CONTAIN CONFIDENTIAL  AND PROPRIETARY
#       INFORMATION.  REPRODUCTION OR DUPLICATION BY ANY MEANS OF ANY
#       PORTION OF THIS SOFTWARE WITHOUT PRIOR WRITTEN CONSENT OF
#       CISCO SYSTEMS, Inc. IS STRICTLY PROHIBITED.
#
#*********************************************************************/

from __future__ import absolute_import
import binascii
import copy
import time
import socket
import estreamer
import estreamer.adapters.kvpair
import estreamer.definitions as definitions
import estreamer.common
import estreamer.adapters.json
from estreamer.ocsf import NetworkActivity
from estreamer.metadata import View
import six

# Syslog settings
SYSLOG_FACILITY_USER   = 1
SYSLOG_PRIORITY_NOTICE = 5

# Calc and save the syslog numeric (do not change, gets calculated)
SYSLOG_NUMERIC = (SYSLOG_FACILITY_USER << 3  | SYSLOG_PRIORITY_NOTICE)

# ocsf header field values
OCSF_VERSION     = 0
OCSF_DEV_VENDOR  = 'Cisco'
OCSF_DEV_PRODUCT = 'Firepower'
OCSF_DEV_VERSION = '6.0'

# Output encoding: ascii / utf8 or hex
PACKET_ENCODING = 'ascii'

def __severity( priority, impact ):
    matrix = {
        1: {  # High
            1: '10',
            2: '9',
            3: '7',
            4: '8',
            5: '9'
        },
        2: {  # Medium
            1: '7',
            2: '6',
            3: '4',
            4: '5',
            5: '6'
        },
        3: {  # Low
            1: '3',
            2: '2',
            3: '0',
            4: '1',
            5: '2'
        }
    }

    if priority in matrix and impact in matrix[priority]:
        return matrix[priority][impact]

    return 5



def __ipv4( ipAddress ):
    if ipAddress.startswith('::ffff:'):
        return ipAddress[7:]

    elif ipAddress.find(':') == -1:
        return ipAddress

    return ''

def __networkActivity( data ) :
    event = NetworkActivity( data )

    return estreamer.adapters.json.dumps(vars(event))

def __ipv6( ipAddress ):
    if ipAddress == '::':
        return ''

    elif ipAddress.startswith('::ffff:'):
        return ''

    elif ipAddress.find(':') > -1:
        return ipAddress

    return ''




MAPPING = {

    # 4001
    definitions.OCSF_NETWORK_ACTIVITY: {

        'name': lambda rec: 'NETWORK ACTIVITY',

        'constants': {
            'activity': 'fwPolicy',
            'cs2Label': 'fwRule',
            'cs3Label': 'ingressZone',
            'category_name': 'network_activity',
            'category_uid': 4,
            'class_name': 'network_activity',
            'class_uid': 4001,
            'connection_info': 'tbd',
        },

        'lambdas': {
            'rt': lambda rec: rec['firstPacketTimestamp'] * 1000,
            'activity_id': lambda x : __networkActivity("test"),
	    'activity': lambda x: "network_activity",
            'category_name': lambda x: "connection_event",
            'category_uid': lambda x: 4,

        },
        'fields': {
            'applicationId': 'app',
            'clientApplicationId': 'requestClientApplication',
            'clientApplicationVersion': '',
            'clientUrl.data': 'request',
            'connectionCounter': 'externalId',
            'destinationAutonomousSystem': '',
            'destinationMask': '',
            'destinationTos': '',
            'deviceId': 'dvchost',
            'dnsQuery.data': 'destinationDnsDomain',
            'dnsRecordType': '',
            'dnsResponseType': '',
            'dnsTtl': '',
            'egressInterface': 'deviceOutboundInterface',
            'egressZone': 'cs4',
            'endpointProfileId': '',
            'fileEventCount': '',
            'firstPacketTimestamp': '', # Used to generate rt and start
            'httpReferrer': '',
            'httpResponse': '',
            'ingressInterface': 'deviceInboundInterface',
            'ingressZone': 'cs3',
            'initiatorBytesDropped': '',
            'initiatorCountry': '',
            'initiatorIpAddress': '',
            'initiatorPacketsDropped': '',
            'initiatorPort': 'spt',
            'initiatorTransmittedBytes': 'bytesOut',
            'initiatorTransmittedPackets': '',
            'instanceId': 'dvcpid',
            'intrusionEventCount': '',
            'iocNumber': '',
            'lastPacketTimestamp': '', # Used to generate end
            'locationIpv6': '',
            'monitorRules1': '',
            'monitorRules2': '',
            'monitorRules3': '',
            'monitorRules4': '',
            'monitorRules5': '',
            'monitorRules6': '',
            'monitorRules7': '',
            'monitorRules8': '',
            'netbios': '',
            'netflowSource': '',
            'networkAnalysisPolicyRevision': '',
            'originalClientCountry': '',
            'originalClientIpAddress': '',
            'policyRevision': 'cs1',
            'protocol': 'proto',
            'qosAppliedInterface': '',
            'qosRuleId': '',
            'referencedHost': '',
            'responderBytesDropped': '',
            'responderCountry': '',
            'responderIpAddress': '',
            'responderPacketsDropped': '',
            'responderPort': 'dpt',
            'responderTransmittedBytes': 'bytesIn',
            'responderTransmittedPackets': '',
            'ruleAction': 'act',
            'ruleId': 'cs2',
            'ruleReason': 'reason',
            'securityContext': '',
            'securityGroupId': '',
            'securityIntelligenceLayer': '',
            'securityIntelligenceList1': 'cs5',
            'securityIntelligenceList2': '',
            'securityIntelligenceSourceDestination': '',
            'sinkholeUuid': '',
            'snmpIn': '',
            'snmpOut': '',
            'sourceAutonomousSystem': '',
            'sourceMask': '',
            'sourceTos': '',
            'sslActualAction': '',
            'sslCertificateFingerprint': '',
            'sslCipherSuite': '',
            'sslExpectedAction': '',
            'sslFlowError': '',
            'sslFlowFlags': '',
            'sslFlowMessages': '',
            'sslFlowStatus': '',
            'sslPolicyId': '',
            'sslRuleId': '',
            'sslServerCertificateStatus': '',
            'sslServerName': '',
            'sslSessionId': '',
            'sslSessionIdLength': '',
            'sslTicketId': '',
            'sslTicketIdLength': '',
            'sslUrlCategory': '',
            'sslVersion': '',
            'tcpFlags': '',
            'tunnelRuleId': '',
            'urlCategory': '',
            'urlReputation': '',
            'userAgent': '',
            'userId': 'suser',
            'vlanId': '',
            'webApplicationId': '',
        },
        'viewdata': {
            View.SENSOR: 'dvchost',
        },
    },

    # 71
    definitions.RECORD_RNA_CONNECTION_STATISTICS: {
        'sig_id': lambda rec: 'RNA:1003:1',

        'name': lambda rec: 'CONNECTION STATISTICS',

        'severity': lambda rec: 3 if rec['ruleAction'] < 4 else 7,

        'constants': {
            'cs1Label': 'fwPolicy',
            'cs2Label': 'fwRule',
            'cs3Label': 'ingressZone',
            'cs4Label': 'egressZone',
            'cs5Label': 'secIntelCategory'
        },

        'lambdas': {
            'rt': lambda rec: rec['firstPacketTimestamp'] * 1000,
            'activity_id': lambda x : __networkActivity("test"),
            'start': lambda rec: rec['firstPacketTimestamp'] * 1000,
            'end': lambda rec: rec['lastPacketTimestamp'] * 1000,
            'src': lambda rec: __ipv4( rec['initiatorIpAddress'] ),
            'dst': lambda rec: __ipv4( rec['responderIpAddress'] ),
            'c6a2': lambda rec: __ipv6( rec['initiatorIpAddress'] ),
            'c6a3': lambda rec: __ipv6( rec['responderIpAddress'] ),
            'deviceExternalId': lambda rec: rec['deviceId'],
        },

        'fields': {
            'description': 'activity',
            'ingressZone': 'cs3',
            'egressZone': 'cs4',
            'ingressInterface': 'deviceInboundInterface',
            'egressInterface': 'deviceOutboundInterface',
            'initiatorIpAddress': '',
            'responderIpAddress': '',
            'originalClientIpAddress': '',
            'policyRevision': 'cs1',
            'ruleId': 'cs2',
            'tunnelRuleId': '',
            'ruleAction': 'act',
            'ruleReason': 'reason',
            'initiatorPort': 'spt',
            'responderPort': 'dpt',
            'tcpFlags': '',
            'protocol': 'proto',
            'netflowSource': '',
            'instanceId': 'dvcpid',
            'connectionCounter': 'externalId',
            'firstPacketTimestamp': '', # Used to generate rt and start
            'lastPacketTimestamp': '', # Used to generate end
            'initiatorTransmittedPackets': '',
            'responderTransmittedPackets': '',
            'initiatorTransmittedBytes': 'bytesOut',
            'responderTransmittedBytes': 'bytesIn',
            'initiatorPacketsDropped': '',
            'responderPacketsDropped': '',
            'initiatorBytesDropped': '',
            'responderBytesDropped': '',
            'qosAppliedInterface': '',
            'qosRuleId': '',
            'userId': 'suser',
            'applicationId': 'app',
            'urlCategory': '',
            'urlReputation': '',
            'clientApplicationId': 'requestClientApplication',
            'webApplicationId': '',
            'clientUrl.data': 'request',
            'netbios': '',
            'clientApplicationVersion': '',
            'monitorRules1': '',
            'monitorRules2': '',
            'monitorRules3': '',
            'monitorRules4': '',
            'monitorRules5': '',
            'monitorRules6': '',
            'monitorRules7': '',
            'monitorRules8': '',
            'securityIntelligenceSourceDestination': '',
            'securityIntelligenceLayer': '',
            'fileEventCount': '',
            'intrusionEventCount': '',
            'initiatorCountry': '',
            'responderCountry': '',
            'originalClientCountry': '',
            'iocNumber': '',
            'sourceAutonomousSystem': '',
            'destinationAutonomousSystem': '',
            'snmpIn': '',
            'snmpOut': '',
            'sourceTos': '',
            'destinationTos': '',
            'sourceMask': '',
            'destinationMask': '',
            'securityContext': '',
            'vlanId': '',
            'referencedHost': '',
            'userAgent': '',
            'httpReferrer': '',
            'sslCertificateFingerprint': '',
            'sslPolicyId': '',
            'sslRuleId': '',
            'sslCipherSuite': '',
            'sslVersion': '',
            'sslServerCertificateStatus': '',
            'sslActualAction': '',
            'sslExpectedAction': '',
            'sslFlowStatus': '',
            'sslFlowError': '',
            'sslFlowMessages': '',
            'sslFlowFlags': '',
            'sslServerName': '',
            'sslUrlCategory': '',
            'sslSessionId': '',
            'sslSessionIdLength': '',
            'sslTicketId': '',
            'sslTicketIdLength': '',
            'networkAnalysisPolicyRevision': '',
            'endpointProfileId': '',
            'securityGroupId': '',
            'locationIpv6': '',
            'httpResponse': '',
            'dnsQuery.data': 'destinationDnsDomain',
            'dnsRecordType': '',
            'dnsResponseType': '',
            'dnsTtl': '',
            'sinkholeUuid': '',
            'securityIntelligenceList1': 'cs5',
            'securityIntelligenceList2': ''
        },

        'viewdata': {
            View.SENSOR: 'dvchost',
            View.SEC_ZONE_INGRESS: 'cs3',
            View.SEC_ZONE_EGRESS: 'cs4',
            View.SEC_INTEL_LIST1: 'cs5',
            View.IFACE_INGRESS: 'deviceInboundInterface',
            View.IFACE_EGRESS: 'deviceOutboundInterface',
            View.FW_POLICY: 'cs1',
            View.FW_RULE: 'cs2',
            View.FW_RULE_ACTION: 'act',
            View.FW_RULE_REASON: 'reason',
            View.PROTOCOL: 'proto',
            View.USER: 'suser',
            View.APP_PROTO: 'app',
            View.CLIENT_APP: 'requestClientApplication',
        },
    },
    # 400
    definitions.RECORD_INTRUSION_EVENT: {
        'sig_id': lambda rec: 'INTRUSION:400:{0}:{1}'.format(
            rec['generatorId'],
            rec['@computed.renderedId']
        ),

        'name': lambda rec: rec['@computed.message'],

        'severity': lambda rec: __severity(
            rec['priorityId'],
            rec['impact'] ),

        'constants': {
            'cs1Label': 'fwPolicy',
            'cs2Label': 'fwRule',
            'cs3Label': 'ingressZone',
            'cs4Label': 'egressZone',
            'cs5Label': 'ipsPolicy',
            'cs6Label': 'ruleId',
            'cn1Label': 'vlan',
            'cn2Label': 'impact',
        },

        'lambdas': {
            'rt': lambda rec: rec['eventSecond'] * 1000,
            'start': lambda rec: rec['connectionTimestamp'] * 1000,
            'src': lambda rec: __ipv4( rec['sourceIpAddress'] ),
            'dst': lambda rec: __ipv4( rec['destinationIpAddress'] ),
            'c6a2': lambda rec: __ipv6( rec['sourceIpAddress'] ),
            'c6a3': lambda rec: __ipv6( rec['destinationIpAddress'] ),
            'deviceExternalId': lambda rec: rec['deviceId'],
            'request': lambda rec: '',
            'act': lambda rec: ['Alerted', 'Blocked', 'Would Be Blocked'][ rec['blocked'] ]
        },

        'viewdata': {
            View.SENSOR: 'dvchost',
            View.CLASSIFICATION_DESCRIPTION: 'cat',
            View.IP_PROTOCOL: 'proto',
            View.IDS_POLICY: 'cs5',
            View.RENDERED_ID: 'cs6',
            View.USER: 'suser',
            View.CLIENT_APP: 'requestClientApplication',
            View.APP_PROTO: 'app',
            View.FW_POLICY: 'cs1',
            View.FW_RULE: 'cs2',
            View.IFACE_INGRESS: 'deviceInboundInterface',
            View.IFACE_EGRESS: 'deviceOutboundInterface',
            View.SEC_ZONE_INGRESS: 'cs3',
            View.SEC_ZONE_EGRESS: 'cs4'
        },

        'fields': {
            'deviceId': 'dvchost',
            'eventId': 'externalId',
            'eventSecond': '', # Used to generate rt
            'eventMicrosecond': '',
            'renderedId': 'cs6', # Used to generate sig_id
            'generatorId': '', # Used to generate sig_id
            'ruleRevision': '',
            'classificationId': 'cat',
            'priorityId': '', # Used to generate severity
            'sourceIpAddress': '',
            'destinationIpAddress': '',
            'sourcePortOrIcmpType': 'spt',
            'destinationPortOrIcmpType': 'dpt',
            'ipProtocolId': 'proto',
            'impactFlags': '',
            'impact': 'cn2', # Used to generate severity
            'blocked': 'act',
            'mplsLabel': '',
            'vlanId': 'cn1',
            'pad': '',
            'policyUuid': 'cs5',
            'userId': 'suser',
            'webApplicationId': '',
            'clientApplicationId': 'requestClientApplication',
            'applicationId': 'app',
            'accessControlRuleId': 'cs2',
            'accessControlPolicyUuid': 'cs1',
            'interfaceIngressUuid': 'deviceInboundInterface',
            'interfaceEgressUuid': 'deviceOutboundInterface',
            'securityZoneIngressUuid': 'cs3',
            'securityZoneEgressUuid': 'cs4',
            'connectionTimestamp': '', # Used to generate start
            'connectionInstanceId': 'dvcpid',
            'connectionCounter': '',
            'sourceCountry': '',
            'destinationCountry': '',
            'iocNumber': '',
            'securityContext': '',
            'sslCertificateFingerprint': '',
            'sslActualAction': '',
            'sslFlowStatus': '',
            'networkAnalysisPolicyUuid': '',
            'httpResponse': '',
        },
    },

}


class Ocsf( object ):
    """ocsf adapter class to contain implementation"""
    def __init__( self, source ):
        self.source = source
        self.record = estreamer.common.Flatdict( source, True )
        self.output = None
        self.mapping = None

        if 'recordType' in self.record:
            if self.record['recordType'] in MAPPING:
                self.mapping = MAPPING[ self.record['recordType'] ]
                self.output = {}



    @staticmethod
    def __sanitize( value ):
        value = str(value)
        
        # Escape \ " ]
        value = value.replace('\\', '\\\\')
        value = value.replace('"', '\\"')
        value = value.replace(']', '\\]')
        value = value.replace('|', '\|')

        return value



    def __convert( self ):
        """Writes the self.output dictionary"""

        # Do the fields first (mapping)
        for source in self.mapping['fields']:
            target = self.mapping['fields'][source]
            if len(target) > 0:
                self.output[target] = self.record[source]

        # Now the constants (hard coded values)
        for target in self.mapping['constants']:
            self.output[target] = self.mapping['constants'][target]

        # Lambdas
        for target in self.mapping['lambdas']:
            function = self.mapping['lambdas'][target]
            self.output[target] = function( self.record )

        # View data last
        for source in self.mapping['viewdata']:
            key = '{0}.{1}'.format( View.OUTPUT_KEY, source )
            value = self.record[key]
            if value is not None:
                target = self.mapping['viewdata'][source]
                self.output[target] = value

        keys = list(self.output.keys())
        for key in keys:
            if isinstance( self.output[ key ], six.string_types) and len( self.output[ key ] ) == 0:
                del self.output[ key ]

            elif self.output[ key ] == 0:
                del self.output[ key ]

            else:
                self.output[ key ] = Ocsf.__sanitize( self.output[ key ] )



    def __ocsfMessage( self ):
        """Takes a transformed dictionary and converts it to a ocsf message"""
        # my ($sig_id, $name, $severity, $message) = @_;

        # my $hostname = hostname();
        # $hostname =~ s/\.+$//;
        hostname = socket.gethostname()

        # http://search.cpan.org/~dexter/POSIX-strftime-GNU-0.02/lib/POSIX/strftime/GNU.pm
        # # Get syslog-style timestamp: MAR  1 16:23:11
        # my $datetime = strftime('%b %e %T', localtime(time()));
        now = time.strftime('%b %d %X')

        # Key value pairs
        data = estreamer.adapters.kvpair.dumps(
            self.output,
            delimiter = ' ',
            quoteSpaces = False,
            sort = True )

        # Special fields
        sigId = self.mapping['sig_id']( self.record )
        name = self.mapping['name']( self.record )
        severity = self.mapping['severity']( self.record )

        # my $ocsf_message = "ocsf:$ocsf_VERSION|$ocsf_DEV_VENDOR|$ocsf_DEV_PRODUCT|
        # ...$ocsf_DEV_VERSION|$sig_id|$name|$severity|$message";
        # # Update the message with the details
        # $message = "<$SYSLOG_NUMERIC>$datetime $hostname $ocsf_message";
        message = u'ocsf:{0}'.format(
            data
        )

        return message



    def dumps( self ):
        """Dumps the current record to a ocsf message (or None)"""
        if self.mapping is None:
            return None

        self.__convert()
        message = self.__ocsfMessage()

        return message



def dumps( source ):
    """Converts a source record into a ocsf message"""
    ocsfAdapter = Ocsf( source )
    return ocsfAdapter.dumps()


